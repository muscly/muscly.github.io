<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🤫&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3B8EKKV9YC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3B8EKKV9YC');
</script>

  <title>NGUI와 간단한 셰이더 포팅&nbsp;|&nbsp;No Secret Wiki</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="NGUI와 간단한 셰이더 포팅">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🤫&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="happiness .html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>행복</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;👨‍💻&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>About</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">NGUI와 간단한 셰이더 포팅</h1>
    
      <div class="DateTagBar">
        
          <span class="DateTagBar__Item DateTagBar__Date">Posted on Sat, Feb 8, 2020</span>
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--blue">
            <a href="tag/URP 포팅.html">URP 포팅</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--default">
            <a href="tag/유니티3D.html">유니티3D</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--yellow">
            <a href="tag/URP.html">URP</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--blue">
            <a href="tag/Shader Graph.html">Shader Graph</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/f6c10fcae34043beb941e77f61e7afe2" class="PageRoot"><div id="https://www.notion.so/58b97dac7dbf416a8dbde43622185d6b" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fff5d729e-b751-4390-9f9f-f12a2443337e%2FUntitled.png?width=696&amp;table=block&amp;id=58b97dac-7dbf-416a-8dbd-e43622185d6b"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fff5d729e-b751-4390-9f9f-f12a2443337e%2FUntitled.png?width=696&amp;table=block&amp;id=58b97dac-7dbf-416a-8dbd-e43622185d6b" style="width:696px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/d5795a2bc18047d69aa2167fd756a9da" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Universal Render Pipeline(이하 URP) 포팅 과정을 기록하는 시리즈의 두 번째 글입니다. 지난 편에서는 렌더링 엔진을 URP로 바꾸는 방법, LWRP 셰이더를 URP로 바꾸는 방법, URP의 내장 포스트 프로세싱 스택에 대해서 적었습니다. 이번 편에서는 NGUI와 자체 제작한 셰이더를 포팅하면서 고민한 내용을 적어보려고 합니다. 작업 메모를 옮긴 것이라 내용이 두서없을 수 있습니다~</span></span></p></div><div id="https://www.notion.so/66673beacc4340a6aad2db9fb74dd762" class="Divider"></div><div id="https://www.notion.so/55fcc3742d924099a12b61ad544e5249" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">NGUI 카메라를 활성화하니 UI는 잘 나오는데 인게임 화면이 나오지 않는다. URP에서 Camera Stacking을 지원하지 않기 때문. 왜 지원하지 않는지 설명해 놓은 문서를 찾았다.</span></span></p></div><div id="https://www.notion.so/f8a509c8998544938814bb560a3beb83" class="Bookmark"><a href="https://docs.google.com/document/d/1GDePoHGMngJ-S0Da0Fi0Ky8jPxYkQD5AkVFnoxlknUY/edit"><h5 class="Bookmark__Title">Camera Rendering in LWRP</h5><p class="Bookmark__Desc">No support for Camera Stacking in LWRP. What: Camera stacking is when a camera depends on the results of a previous one. In built-in render pipeline users achieve camera stacking by configuring a first camera with skybox or color clear. Then setup a second camera with DepthOnly or DontClear flag...</p><p class="Bookmark__Link">https://docs.google.com/document/d/1GDePoHGMngJ-S0Da0Fi0Ky8jPxYkQD5AkVFnoxlknUY/edit</p></a></div><div id="https://www.notion.so/f194c8a17a4b4a1da3d86468b65a11cf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">유니티에서 Camera Stacking을 지원하면서 여러 가지 버그 때문에 고생을 했나보다. 성능 고민도 있었던 것 같고. 어쨌든 의도적으로 Camera Stacking을 지원하지 않는 것 같은데, 기능을 비교해놓은 문서를 보면 또 Camera Stacking 기능은 In Research라고 나온다. 다음 버전에서는 지원할 수도 있다는 얘기일까.</span></span></p></div><div id="https://www.notion.so/61ae5886a6e74cc49fef6e56cdd21c8f" class="Bookmark"><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%407.1/manual/universalrp-builtin-feature-comparison.html"><h5 class="Bookmark__Title">Feature comparison table</h5><p class="Bookmark__Desc">This table provides an overview of the current features supported in the Universal Render Pipeline (URP), compared to the Unity Built-in render pipeline. Note: If a feature is marked In research, the URP team is still researching how and when to implement the feature.</p><p class="Bookmark__Link">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%407.1/manual/universalrp-builtin-feature-comparison.html</p></a></div><div id="https://www.notion.so/64a5ea7954274354a0495f3dd6565407" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">우선 생각해볼 수 있는 방법은 Render Texture를 사용하기. 인게임 카메라를 Render Texture로 찍고, NGUI의 배경에 그 Render Texture를 한 번 그려주는 방식. 동작은 잘한다. Frame Debugger로 원래 프레임 버퍼의 포맷을 확인해서 Render Texture의 포맷도 맞춰주면 Bloom도 잘 된다. 좀 더 테스트를 해봐야지.</span></span></p></div><div id="https://www.notion.so/bf0a0b175e1e44919e9381346462ec98" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">장점은 Render Texture의 크기를 조절하는 것만으로 간단하게 Upscale Sampling이 되는 것. 어차피 Upscale Sampling을 해야 해서 잘됐다 싶기도 하고.</span></span></p></div><div id="https://www.notion.so/85becf6459064e70a46ca9600d698e4f" class="ColorfulBlock ColorfulBlock--BgGray Callout"><div class="Callout__Icon"><div class="Icon">💡</div></div><p class="Callout__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Upscale Sampling 이란
</strong></strong></span><span class="SemanticString">인게임의 해상도를 낮춰서 성능을 향상하면서, UI 해상도는 높게 해서 해상도가 낮아진 것이 잘 눈에 띄지 않도록 만드는 방법입니다.</span></span></p></div><div id="https://www.notion.so/0494ab39838d45848464173fa82f41a6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">근데 유니티 내장 uGUI를 사용하면 URP 애셋의 Render Scale을 조절하는 것만으로 Upscale Sampling이 된단다. 내부적으로 Render Texture 방식을 쓰는 것인지 혹은 좀 더 효율적인 방법으로 구현된 것인지 확인할 필요가 있다. 우선은 돌아는 가니까 다음 스텝으로 넘어가자.</span></span></p></div><div id="https://www.notion.so/d6e78021b1d2428f8336ec3d940b7fb4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">할 일 추가: </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">URP와 uGUI의 구현 원리 파악</strong></span></span></p></div><div id="https://www.notion.so/afd365194807451ba4604b7b96afe855" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">인게임 플레이 테스트를 하다 보니 Grab Pass를 쓴 경우에 인게임 화면이 나오지 않는다. URP에서는 Grab Pass는 쓸 수 없고 대신에 URP Asset에 있는 Opaque Texture 옵션을 사용하거나 카메라 별로 오버라이드 할 수 있다고 한다. 나중에 다시 보자.</span></span></p></div><div id="https://www.notion.so/21b83365a8cd4ccd8c773b925ea52f6e" class="Bookmark"><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.1/manual/universalrp-asset.html"><h5 class="Bookmark__Title">Universal Render Pipeline Asset</h5><p class="Bookmark__Desc">To use the Universal Render Pipeline (URP), you have to create a URP Asset and assign the asset in the Graphics settings. The URP Asset controls several graphical features and quality settings for the Universal Render Pipeline. It is a scriptable object that inherits from &#x27;RenderPipelineAsset&#x27;.</p><p class="Bookmark__Link">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.1/manual/universalrp-asset.html</p></a></div><div id="https://www.notion.so/e79dd6e5699d43d4bd5d5a182a0b486e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">할 일 추가: </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Grab Pass를 Opaque Texture로 대체</strong></span></span></p></div><div id="https://www.notion.so/39dff8198ced42c7a87cb1bc53af8636" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">이제 구매한 애셋인데 URP 지원이 없거나 자체 제작한 셰이더들을 포팅할 차례. 가장 간단한 몹 셰이더부터. 서피스 셰이더처럼 서피스 함수랑 라이팅 함수만 구현하면 알아서 코드 생성을 해주는 기능은 없나보다. URP의 표준 셰이더인 Lit 셰이더를 열어보니 vertex와 frag를 직접 코딩하고 있다. Lit 셰이더를 참조해서 만들면 어찌어찌 될 것은 같은데, 아티스트분들이 직접 만질 수 있으면 좋으니 Shader Graph로 변경.</span></span></p></div><div id="https://www.notion.so/5b524e04c56f450b902dba68f8fe27c8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Shader Graph로 하면 키워드로 #ifdef 분기하는 것은 어떻게 하는지 궁금하다. 역시 매뉴얼부터 읽어봐야겠지.</span></span></p></div><div id="https://www.notion.so/16d7a54b9f28492cbdde89b8715ef245" class="Bookmark"><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph%407.1/manual/index.html"><h5 class="Bookmark__Title">About Shader Graph</h5><p class="Bookmark__Desc">Shader Graph enables you to build shaders visually. Instead of writing code, you create and connect nodes in a graph framework. Shader Graph gives instant feedback that reflects your changes, and it&#x27;s simple enough for users who are new to shader creation. For an introduction to Shader Graph, see Getting Started.</p><p class="Bookmark__Link">https://docs.unity3d.com/Packages/com.unity.shadergraph%407.1/manual/index.html</p></a></div><div id="https://www.notion.so/c700e59cefad4a04b90eae7a8caa811c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">키워드 기능은 있다. 많이 좋아졌네. 작업하다 보니 우리 Metallic Map이 RGB로 되어 있는데 이거 모노 바꿔야겠다. 역시 URP로 포팅하다 보니 꼼꼼하게 보게 된다.</span></span></p></div><div id="https://www.notion.so/b75fe9375e01419c8a7620015c1cc208" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">PBR Master를 사용해서 그래프를 하나 만들고 우리 프로젝트에서 쓰는 방식으로 맵만 연결해주면 끝. 작업은 간단한데 코딩하는 것보다는 오래 걸린다. 프로그래머 입장에서는 텍스트로 된 셰이더 파일이 눈에 더 잘 들어온다. 사실상 이런 간단한 셰이더는 프로퍼티 받아서 텍스쳐 샘플링하고 이리저리 값 곱해줘서 Albedo, Normal 등등을 세팅해주는 게 끝이라서, 어느 프로퍼티가 어디로 들어가는지는 텍스트로 된 코드가 더 명확하게 보인다. 반면에 Shader Graph는 중간중간 결과를 눈으로 볼 수 있고, HLSL 문법을 몰라도 작업할 수 있으니 아티스트 분들에게는 도움이 되겠지?</span></span></p></div><div id="https://www.notion.so/bcbfa93d88db4253870c8a67350e30b7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">이제 몸도 풀었으니 복잡한 셰이더에 도전해보자. 몹 셰이더처럼 유니티의 PBR Lighting을 쓰는 간단한 셰이더 말고, 헤어와 스킨 셰이더처럼 자체적인 라이팅을 구현한 것들. 사실 이런 셰이더야말로 Shader Graph로 구현되어야 아티스트 분들이 이런저런 수정을 해볼 수 있는데, Shader Graph로 만들기 애매한 부분이 있다.</span></span></p></div><div id="https://www.notion.so/e412f8953f8d4857af2a7e393e983a46" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Shader Graph로 커스텀 라이팅을 구현하려면 Unlit Master를 사용하고 직접 계산한 라이팅을 Emission 노드에 연결해줘야 한다. 문제는 여러 광원을 쓸 때 모든 광원에 대한 처리를 직접 구현해 주어야 한다. PBR Master를 쓰면 하나의 Shader Graph를 광원 개수만큼 돌리면서 알아서 처리해준다. 또, 예전에 테스트했을 때는 Unlit Master를 쓰면 Shadow Map을 받지 못해서 다른 오브젝트의 그림자를 받지 못하는 문제가 있었다. 어찌어찌 다 해결할 수 있다고 해도 뭔가 억지로 쓰는 느낌이 들어서 토이 프로젝트가 아닌 이상에야 찝찝한 기분이 든다.</span></span></p></div><div id="https://www.notion.so/cbc5a5e479aa482ebb0e75da401d2d3a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><span class="SemanticString__Fragment SemanticString__Fragment--Resource"><a href="toon-shading-universalrp.html"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Universal RP로 구현한 툰 셰이딩</strong></span></span></a></span></span><span class="SemanticString"> </span></span></p></div><div id="https://www.notion.so/6f5797136160449cacfdb69253ba33fb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">아무래도 복잡하고 성능이 중요한 셰이더를 Shader Graph로 만드는 것은 리스크가 있어 보인다. URP에서의 셰이더 코딩도 익힐 겸 HLSL로 가자.</span></span></p></div><div id="https://www.notion.so/7075759790324027a771640c71944469" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Albedo와 Normal을 지원하고 Albedo.a에 smoothness를 넣는 간단한 Lit 셰이더로 연습을 하자. URP의 Lit 셰이더를 가져다가 고쳐보기로 하자.</span></span></p></div><div id="https://www.notion.so/ee258a77d2154ec09160b858e896abe9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">기존의 서피스 셰이더는 surface 함수와 light 함수를 코딩하면 유니티가 알아서 필요한 pass를 생성해주는 식이었는데, 이제는 그런 게 없고 바로 vert, fragment 함수를 짜야 한다. Lit 셰이더를 보니 여러 패스를 구현하기 쉽게 셰이더를 쪼개 놓았고, 입력 처리는 LitInput.hlsl에서 각 패스를 LitForwardPass.hlsl이나 LitMetaPass.hlsl 같은 함수에서 구현했다.</span></span></p></div><div id="https://www.notion.so/138d064810fc4727ad78a999cf9c8ca4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">어쨌든 Lit 셰이더에서 불필요한 #ifdef와 기능을 다 제거하면서 만들어 보니 어렵지 않다. 근데 Normal이 안먹는다. 이유는 Normal을 샘플링하는 유틸 함수가 URP의 SurfaceInput.hlsl 안에 있는데 _NORMALMAP 키워드로 감싸져있기 때문. 간단한 함수이므로 복사해와서 고쳐서 쓰니까 잘된다.</span></span></p></div><div id="https://www.notion.so/76bc05fabbe645dca9cb051ee4a84f98" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">다른 패스들은 ShadowCaster, DepthOnly, Meta, Universal2D 가 있는데, 이미 구현된 셰이더 패스를 재활용해주면 된다. 추가로 코딩할 것은 없고 #include만 잘 하면 된다. 근데, 그렇게 하고나니 이 지글지글한 패턴이 나온다. 어디서 나온거지.</span></span></p></div><div id="https://www.notion.so/7c74d22ccc334bffbc899f36f6061196" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ShadowCaster 패스 같은 곳에서 컴파일 에러가 나는 것이 원인. Alphatest를 쓸 일이 없어서 _Cutoff 변수를 지워버렸는데, ShadowCaster나 DepthOnly 패스에서는 구멍을 뚫어야 해서 _Cutoff를 참조한다. 문제는 _ALPHATEST_ON 키워드를 정의하지 않아도 참조를 한다는 것인데, 결국에 최종적으로 clip()을 호출하는 부분은 _ALPHATEST_ON으로 감싸져 있어서 실제로 부하는 없을 것 같다.</span></span></p></div><div id="https://www.notion.so/cc534b1e7a9a46859c2d9e4fa229d5f1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ShaderCasterPass.hlsl이나 DepthOlayPass.hlsl을 하나 복사해서 _Cutoff 참조를 안하게 고쳐주는 것도 방법이지만, 나중에 관리비용이 들 것 같으니 그냥 LitInput.hlsl에서 _Cutoff를 살려주는 것이 제일 나은 해결책.</span></span></p></div><div id="https://www.notion.so/3bf1d1ddc03b4b6a8fb0bc00e39401ab" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">음, 처음에 겁먹었는데 한 번 만들어보니 별 것 없다. 오늘은 여기까지.</span></span></p></div><div id="https://www.notion.so/5486b5ea9d8b4939a4520278ca8d9bf6" class="ColorfulBlock ColorfulBlock--BgGray Callout"><div class="Callout__Icon"><div class="Icon">💡</div></div><p class="Callout__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">NGUI 업데이트
</strong></span><span class="SemanticString">NGUI의 최신 업데이트인 2019.3에서는 하나의 카메라를 사용해서 UI를 그릴 수 있는 기능이 추가되었습니다. 이후 포스트에서 NGUI 2019.3 적용기를 공유해보겠습니다~</span></span></p></div><div id="https://www.notion.so/50d2df5d74bd4d43a9fc829ac79f96db" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
    
  <script src="https://utteranc.es/client.js"
        repo="muscly/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
  </script>
    
  <footer class="Footer">
  <div>&copy; No Secret Wiki 2019-2021</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>
